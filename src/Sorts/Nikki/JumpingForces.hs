{-# language ViewPatterns #-}

module Sorts.Nikki.JumpingForces where


import Data.Abelian
import Data.Directions
import qualified Data.Strict as Strict

import Physics.Chipmunk

import Base

import Sorts.Nikki.Types
import Sorts.Nikki.Configuration
import Sorts.Nikki.JumpingImpulse


-- | returns both the anti gravity force and the horizontal airborne force
getJumpingForces :: Seconds -> Action -> JumpInformation -> Vector
getJumpingForces now action ji =
    Vector airborneForce (getLongJumpingForce now ji)
  where
    airborneForce = airborne (jumpButtonDirection ji) action (jumpNikkiVelocity ji)

-- | Returns the horizontal force while nikki touches nothing
-- and the left xor right button is pressed.
-- In a SlideToGrip state, the movement towards the touched object is not possible.
airborne :: Strict.Maybe HorizontalDirection -> Action -> Velocity -> CpFloat
airborne (Strict.Just buttonDirection) (SlideToGrip wallDirection) _
    | buttonDirection == wallDirection = 0
airborne (Strict.Just HLeft) _ velocity =
    if vectorX velocity > (- maximumWalkingVelocity) then (- airForce) else 0
airborne (Strict.Just HRight) _ velocity =
    if vectorX velocity < maximumWalkingVelocity then airForce else 0
airborne Strict.Nothing _ _ = 0

-- | force that will be applied horizontally, if applicable
airForce = gravity * nikkiMass * airBorneForceFactor

-- | returns the force that causes the maximal jump (some kind of antigravity)
-- which will be applied when the jump button is held
getLongJumpingForce :: Seconds -> JumpInformation -> CpFloat
getLongJumpingForce now ji =
    case (jumpStartTime ji, jumpCollisionAngle ji) of
        (Strict.Just jumpStartTime_, Strict.Just collisionAngle) ->
            longJumpAntiGravity (now - jumpStartTime_) *
            getJumpingFactor collisionAngle
        _ -> zero

-- | calculates the force that is applied in a maximal jump
-- depending on the time
longJumpAntiGravity :: Seconds -> CpFloat
longJumpAntiGravity t = negate $
    if t < t_s
    then q_a * t ^ 2 + s_a * t + c_a
    else 0
  where

    h = maximalJumpingHeight
    c_vi = jumpingImpulseLength / nikkiMass
    g = gravity
    mass = nikkiMass

    -- generated by maxima
    q_a = (6*c_vi*g^3*sqrt(16*g*h+c_vi^2)-24*g^4*h-6*c_vi^2*g^3)*mass
            /(-32*g^2*h^2+sqrt(16*g*h+c_vi^2)*(8*c_vi*g*h+c_vi^3)
                         -16*c_vi^2*g*h-c_vi^4)
    s_a = (sqrt(16*g*h+c_vi^2)*(96*g^4*h^2+120*c_vi^2*g^3*h+12*c_vi^4*g^2)
            -672*c_vi*g^4*h^2-216*c_vi^3*g^3*h-12*c_vi^5*g^2)
            *mass
            /(-128*g^3*h^3+sqrt(16*g*h+c_vi^2)
                           *(48*c_vi*g^2*h^2+16*c_vi^3*g*h+c_vi^5)
                          -144*c_vi^2*g^2*h^2-24*c_vi^4*g*h-c_vi^6)
    c_a = (-1536*g^5*h^4+sqrt(16*g*h+c_vi^2)
                             *(960*c_vi*g^4*h^3+768*c_vi^3*g^3*h^2
                                               +132*c_vi^5*g^2*h+6*c_vi^7*g)
                            -4416*c_vi^2*g^4*h^3-1632*c_vi^4*g^3*h^2
                            -180*c_vi^6*g^2*h-6*c_vi^8*g)
            *mass
            /(-512*g^4*h^4+sqrt(16*g*h+c_vi^2)
                           *(256*c_vi*g^3*h^3+160*c_vi^3*g^2*h^2+24*c_vi^5*g*h
                                             +c_vi^7)-1024*c_vi^2*g^3*h^3
                          -320*c_vi^4*g^2*h^2-32*c_vi^6*g*h-c_vi^8)
    c_v = c_vi
    c_p = 0
    t_s = (sqrt(16*g*h+c_vi^2)-c_vi)/(2*g)
